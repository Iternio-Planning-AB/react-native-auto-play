///
/// JNitroManeuver.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include <fbjni/fbjni.h>
#include "NitroManeuver.hpp"

#include "AttributedInstructionVariant.hpp"
#include "AttributedInstructionVariantImage.hpp"
#include "AutoText.hpp"
#include "Distance.hpp"
#include "DistanceUnits.hpp"
#include "DurationWithTimeZone.hpp"
#include "JAttributedInstructionVariant.hpp"
#include "JAttributedInstructionVariantImage.hpp"
#include "JAutoText.hpp"
#include "JDistance.hpp"
#include "JDistanceUnits.hpp"
#include "JDurationWithTimeZone.hpp"
#include "JJunctionType.hpp"
#include "JLane.hpp"
#include "JLaneGuidance.hpp"
#include "JLaneStatus.hpp"
#include "JManeuverType.hpp"
#include "JNitroImage.hpp"
#include "JTrafficSide.hpp"
#include "JTravelEstimates.hpp"
#include "JunctionType.hpp"
#include "Lane.hpp"
#include "LaneGuidance.hpp"
#include "LaneStatus.hpp"
#include "ManeuverType.hpp"
#include "NitroImage.hpp"
#include "TrafficSide.hpp"
#include "TravelEstimates.hpp"
#include <optional>
#include <string>
#include <vector>

namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid {

  using namespace facebook;

  /**
   * The C++ JNI bridge between the C++ struct "NitroManeuver" and the the Kotlin data class "NitroManeuver".
   */
  struct JNitroManeuver final: public jni::JavaClass<JNitroManeuver> {
  public:
    static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/at/g4rb4g3/autoplay/hybrid/NitroManeuver;";

  public:
    /**
     * Convert this Java/Kotlin-based struct to the C++ struct NitroManeuver by copying all values to C++.
     */
    [[maybe_unused]]
    [[nodiscard]]
    NitroManeuver toCpp() const {
      static const auto clazz = javaClassStatic();
      static const auto fieldId = clazz->getField<jni::JString>("id");
      jni::local_ref<jni::JString> id = this->getFieldValue(fieldId);
      static const auto fieldAttributedInstructionVariants = clazz->getField<jni::JArrayClass<JAttributedInstructionVariant>>("attributedInstructionVariants");
      jni::local_ref<jni::JArrayClass<JAttributedInstructionVariant>> attributedInstructionVariants = this->getFieldValue(fieldAttributedInstructionVariants);
      static const auto fieldTravelEstimates = clazz->getField<JTravelEstimates>("travelEstimates");
      jni::local_ref<JTravelEstimates> travelEstimates = this->getFieldValue(fieldTravelEstimates);
      static const auto fieldManeuverType = clazz->getField<JManeuverType>("maneuverType");
      jni::local_ref<JManeuverType> maneuverType = this->getFieldValue(fieldManeuverType);
      static const auto fieldTrafficSide = clazz->getField<JTrafficSide>("trafficSide");
      jni::local_ref<JTrafficSide> trafficSide = this->getFieldValue(fieldTrafficSide);
      static const auto fieldRoadFollowingManeuverVariants = clazz->getField<jni::JArrayClass<jni::JString>>("roadFollowingManeuverVariants");
      jni::local_ref<jni::JArrayClass<jni::JString>> roadFollowingManeuverVariants = this->getFieldValue(fieldRoadFollowingManeuverVariants);
      static const auto fieldSymbolImage = clazz->getField<JNitroImage>("symbolImage");
      jni::local_ref<JNitroImage> symbolImage = this->getFieldValue(fieldSymbolImage);
      static const auto fieldJunctionImage = clazz->getField<JNitroImage>("junctionImage");
      jni::local_ref<JNitroImage> junctionImage = this->getFieldValue(fieldJunctionImage);
      static const auto fieldJunctionType = clazz->getField<JJunctionType>("junctionType");
      jni::local_ref<JJunctionType> junctionType = this->getFieldValue(fieldJunctionType);
      static const auto fieldJunctionExitAngle = clazz->getField<jni::JDouble>("junctionExitAngle");
      jni::local_ref<jni::JDouble> junctionExitAngle = this->getFieldValue(fieldJunctionExitAngle);
      static const auto fieldJunctionElementAngles = clazz->getField<jni::JArrayDouble>("junctionElementAngles");
      jni::local_ref<jni::JArrayDouble> junctionElementAngles = this->getFieldValue(fieldJunctionElementAngles);
      static const auto fieldHighwayExitLabel = clazz->getField<jni::JString>("highwayExitLabel");
      jni::local_ref<jni::JString> highwayExitLabel = this->getFieldValue(fieldHighwayExitLabel);
      static const auto fieldLinkedLaneGuidance = clazz->getField<JLaneGuidance>("linkedLaneGuidance");
      jni::local_ref<JLaneGuidance> linkedLaneGuidance = this->getFieldValue(fieldLinkedLaneGuidance);
      return NitroManeuver(
        id->toStdString(),
        [&]() {
          size_t __size = attributedInstructionVariants->size();
          std::vector<AttributedInstructionVariant> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = attributedInstructionVariants->getElement(__i);
            __vector.push_back(__element->toCpp());
          }
          return __vector;
        }(),
        travelEstimates->toCpp(),
        maneuverType->toCpp(),
        trafficSide->toCpp(),
        roadFollowingManeuverVariants != nullptr ? std::make_optional([&]() {
          size_t __size = roadFollowingManeuverVariants->size();
          std::vector<std::string> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = roadFollowingManeuverVariants->getElement(__i);
            __vector.push_back(__element->toStdString());
          }
          return __vector;
        }()) : std::nullopt,
        symbolImage->toCpp(),
        junctionImage != nullptr ? std::make_optional(junctionImage->toCpp()) : std::nullopt,
        junctionType != nullptr ? std::make_optional(junctionType->toCpp()) : std::nullopt,
        junctionExitAngle != nullptr ? std::make_optional(junctionExitAngle->value()) : std::nullopt,
        junctionElementAngles != nullptr ? std::make_optional([&]() {
          size_t __size = junctionElementAngles->size();
          std::vector<double> __vector(__size);
          junctionElementAngles->getRegion(0, __size, __vector.data());
          return __vector;
        }()) : std::nullopt,
        highwayExitLabel != nullptr ? std::make_optional(highwayExitLabel->toStdString()) : std::nullopt,
        linkedLaneGuidance != nullptr ? std::make_optional(linkedLaneGuidance->toCpp()) : std::nullopt
      );
    }

  public:
    /**
     * Create a Java/Kotlin-based struct by copying all values from the given C++ struct to Java.
     */
    [[maybe_unused]]
    static jni::local_ref<JNitroManeuver::javaobject> fromCpp(const NitroManeuver& value) {
      return newInstance(
        jni::make_jstring(value.id),
        [&]() {
          size_t __size = value.attributedInstructionVariants.size();
          jni::local_ref<jni::JArrayClass<JAttributedInstructionVariant>> __array = jni::JArrayClass<JAttributedInstructionVariant>::newArray(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            const auto& __element = value.attributedInstructionVariants[__i];
            __array->setElement(__i, *JAttributedInstructionVariant::fromCpp(__element));
          }
          return __array;
        }(),
        JTravelEstimates::fromCpp(value.travelEstimates),
        JManeuverType::fromCpp(value.maneuverType),
        JTrafficSide::fromCpp(value.trafficSide),
        value.roadFollowingManeuverVariants.has_value() ? [&]() {
          size_t __size = value.roadFollowingManeuverVariants.value().size();
          jni::local_ref<jni::JArrayClass<jni::JString>> __array = jni::JArrayClass<jni::JString>::newArray(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            const auto& __element = value.roadFollowingManeuverVariants.value()[__i];
            __array->setElement(__i, *jni::make_jstring(__element));
          }
          return __array;
        }() : nullptr,
        JNitroImage::fromCpp(value.symbolImage),
        value.junctionImage.has_value() ? JNitroImage::fromCpp(value.junctionImage.value()) : nullptr,
        value.junctionType.has_value() ? JJunctionType::fromCpp(value.junctionType.value()) : nullptr,
        value.junctionExitAngle.has_value() ? jni::JDouble::valueOf(value.junctionExitAngle.value()) : nullptr,
        value.junctionElementAngles.has_value() ? [&]() {
          size_t __size = value.junctionElementAngles.value().size();
          jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
          __array->setRegion(0, __size, value.junctionElementAngles.value().data());
          return __array;
        }() : nullptr,
        value.highwayExitLabel.has_value() ? jni::make_jstring(value.highwayExitLabel.value()) : nullptr,
        value.linkedLaneGuidance.has_value() ? JLaneGuidance::fromCpp(value.linkedLaneGuidance.value()) : nullptr
      );
    }
  };

} // namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid
