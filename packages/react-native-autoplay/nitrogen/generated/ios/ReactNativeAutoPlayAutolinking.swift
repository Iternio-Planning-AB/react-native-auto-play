///
/// ReactNativeAutoPlayAutolinking.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

public final class ReactNativeAutoPlayAutolinking {
  public typealias bridge = margelo.nitro.swe.iternio.reactnativeautoplay.bridge.swift

  /**
   * Creates an instance of a Swift class that implements `HybridAutoPlaySpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridAutoPlaySpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `HybridAutoPlay`).
   */
  public static func createAutoPlay() -> bridge.std__shared_ptr_HybridAutoPlaySpec_ {
    let hybridObject = HybridAutoPlay()
    return { () -> bridge.std__shared_ptr_HybridAutoPlaySpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridListTemplateSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridListTemplateSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `HybridListTemplate`).
   */
  public static func createListTemplate() -> bridge.std__shared_ptr_HybridListTemplateSpec_ {
    let hybridObject = HybridListTemplate()
    return { () -> bridge.std__shared_ptr_HybridListTemplateSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridInformationTemplateSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridInformationTemplateSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `HybridInformationTemplate`).
   */
  public static func createInformationTemplate() -> bridge.std__shared_ptr_HybridInformationTemplateSpec_ {
    let hybridObject = HybridInformationTemplate()
    return { () -> bridge.std__shared_ptr_HybridInformationTemplateSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridGridTemplateSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridGridTemplateSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `HybridGridTemplate`).
   */
  public static func createGridTemplate() -> bridge.std__shared_ptr_HybridGridTemplateSpec_ {
    let hybridObject = HybridGridTemplate()
    return { () -> bridge.std__shared_ptr_HybridGridTemplateSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridMapTemplateSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridMapTemplateSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `HybridMapTemplate`).
   */
  public static func createMapTemplate() -> bridge.std__shared_ptr_HybridMapTemplateSpec_ {
    let hybridObject = HybridMapTemplate()
    return { () -> bridge.std__shared_ptr_HybridMapTemplateSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridMessageTemplateSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridMessageTemplateSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `HybridMessageTemplate`).
   */
  public static func createMessageTemplate() -> bridge.std__shared_ptr_HybridMessageTemplateSpec_ {
    let hybridObject = HybridMessageTemplate()
    return { () -> bridge.std__shared_ptr_HybridMessageTemplateSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridSearchTemplateSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridSearchTemplateSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `HybridSearchTemplate`).
   */
  public static func createSearchTemplate() -> bridge.std__shared_ptr_HybridSearchTemplateSpec_ {
    let hybridObject = HybridSearchTemplate()
    return { () -> bridge.std__shared_ptr_HybridSearchTemplateSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridCarPlayDashboardSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridCarPlayDashboardSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `HybridCarPlayDashboard`).
   */
  public static func createCarPlayDashboard() -> bridge.std__shared_ptr_HybridCarPlayDashboardSpec_ {
    let hybridObject = HybridCarPlayDashboard()
    return { () -> bridge.std__shared_ptr_HybridCarPlayDashboardSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridClusterSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridClusterSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `HybridCluster`).
   */
  public static func createCluster() -> bridge.std__shared_ptr_HybridClusterSpec_ {
    let hybridObject = HybridCluster()
    return { () -> bridge.std__shared_ptr_HybridClusterSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
}
